/* Generated by Phoenix Tuner X */
package frc.robot.subsystems;

import static edu.wpi.first.units.Units.*;

import java.util.function.DoubleSupplier;
import java.util.function.Supplier;

import com.ctre.phoenix6.BaseStatusSignal;
import com.ctre.phoenix6.CANBus;
import com.ctre.phoenix6.StatusSignal;
import com.ctre.phoenix6.Utils;
import com.ctre.phoenix6.configs.TalonFXConfiguration;
import com.ctre.phoenix6.controls.DutyCycleOut;
import com.ctre.phoenix6.controls.MotionMagicVoltage;
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.signals.ForwardLimitSourceValue;
import com.ctre.phoenix6.signals.ForwardLimitTypeValue;
import com.ctre.phoenix6.signals.GravityTypeValue;
import com.ctre.phoenix6.signals.MotorAlignmentValue;
import com.ctre.phoenix6.signals.NeutralModeValue;
import com.ctre.phoenix6.signals.ReverseLimitSourceValue;
import com.ctre.phoenix6.signals.ReverseLimitTypeValue;
import com.ctre.phoenix6.sim.ChassisReference;
import com.ctre.phoenix6.sim.TalonFXSimState;

import edu.wpi.first.math.system.plant.DCMotor;
import edu.wpi.first.units.measure.*;
import edu.wpi.first.wpilibj.Notifier;
import edu.wpi.first.wpilibj.RobotController;
import edu.wpi.first.wpilibj.simulation.ElevatorSim;
import edu.wpi.first.wpilibj.smartdashboard.Mechanism2d;
import edu.wpi.first.wpilibj.smartdashboard.MechanismLigament2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj2.command.button.Trigger;

public class Elevator extends SubsystemBase {
    /** Position setpoints for the elevator. */
    public enum Setpoint {
        Ground(Rotations.of(0)),
        Middle(Rotations.of(0.7)),
        Top(Rotations.of(1.3));

        /** The position target of the setpoint in angular units. */
        public final Angle target;
        /** The position target of the setpoint in linear units. */
        public final Distance targetDist;

        private Setpoint(Angle target) {
            this.target = target;
            this.targetDist = kDrumRadius.times(target.in(Radians));
        }
        private Setpoint(Distance target) {
            this.target = Radians.of(target.div(kDrumRadius).magnitude());
            this.targetDist = target;
        }
    }

    private static final int kNumConfigAttempts = 2;

    private static final double kGearRatio = 1.2;
    private static final Distance kDrumRadius = Meters.of(0.028575);
    private static final Distance kMaxHeight = Meters.of(0);

    /* leader and follower motors */
    private final CANBus kCANBus = new CANBus("drive");
    private final TalonFX motor_id_0 = new TalonFX(0, kCANBus);

    /* device status signals */
    private final StatusSignal<Angle> motor_id_0Position = motor_id_0.getPosition(false);
    private final StatusSignal<AngularVelocity> motor_id_0Velocity = motor_id_0.getVelocity(false);
    private final StatusSignal<Current> motor_id_0TorqueCurrent = motor_id_0.getTorqueCurrent(false);

    /* controls used by the leader motors */
    private final MotionMagicVoltage setpointRequest = new MotionMagicVoltage(0);
    private final DutyCycleOut manualRequest = new DutyCycleOut(0);
    private final DutyCycleOut calibrationRequest = new DutyCycleOut(-0.1)
        .withIgnoreHardwareLimits(true)
        .withIgnoreSoftwareLimits(true);

    /** Trigger to detect when the elevator drives into a hard stop. */
    public final Trigger isHardStop = new Trigger(() -> {
        return motor_id_0Velocity.getValue().abs(RotationsPerSecond) < 1 &&
            motor_id_0TorqueCurrent.getValue().abs(Amps) > 10;
    }).debounce(0.1);

    /* simulation */
    private final ElevatorSim elevatorSim_motor_id_0 = new ElevatorSim(
        DCMotor.getKrakenX60Foc(1),
        kGearRatio, 5, kDrumRadius.in(Meters),
        0.0, kMaxHeight.in(Meters), true, 0.0
    );

    private static final double kSimLoopPeriod = 0.002; // 2 ms
    private Notifier simNotifier = null;
    private double lastSimTime = 0.0;

    /* Mechanism2d visualization of the elevator */
    private final Mechanism2d mech2d = new Mechanism2d(1, kMaxHeight.in(Meters));
    private final MechanismLigament2d motor_id_0Mech2d = mech2d.getRoot("motor_id_0 Root", 0.500, 0)
        .append(new MechanismLigament2d("motor_id_0", elevatorSim_motor_id_0.getPositionMeters(), 90));

    /** Configs common across all motors. */
    private static final TalonFXConfiguration motorInitialConfigs = new TalonFXConfiguration();

    /** Configs common across just the leader motors. */
    private static final TalonFXConfiguration leaderInitialConfigs = motorInitialConfigs.clone();

    /** Configs for {@link #motor_id_0}. */
    private final TalonFXConfiguration motor_id_0Configs = leaderInitialConfigs.clone()
        .withMotorOutput(
            leaderInitialConfigs.MotorOutput.clone()
                .withNeutralMode(NeutralModeValue.Coast)
        )
        .withCurrentLimits(
            leaderInitialConfigs.CurrentLimits.clone()
                .withStatorCurrentLimit(Amps.of(120))
                .withStatorCurrentLimitEnable(true)
        )
        .withSlot0(
            leaderInitialConfigs.Slot0.clone()
                .withKP(2.4)
                .withKI(0)
                .withKD(0)
                .withKS(0.2)
                .withKV(0.144)
                .withKA(0)
                .withKG(0.5)
                .withGravityType(GravityTypeValue.Elevator_Static)
        )
        .withFeedback(
            leaderInitialConfigs.Feedback.clone()
                .withSensorToMechanismRatio(1.2)
        )
        .withHardwareLimitSwitch(
            leaderInitialConfigs.HardwareLimitSwitch.clone()
                .withForwardLimitEnable(true)
                .withForwardLimitAutosetPositionEnable(false)
                .withForwardLimitRemoteSensorID(0)
                .withForwardLimitSource(ForwardLimitSourceValue.LimitSwitchPin)
                .withForwardLimitType(ForwardLimitTypeValue.NormallyOpen)
                .withReverseLimitAutosetPositionEnable(false)
                .withReverseLimitEnable(true)
                .withReverseLimitRemoteSensorID(0)
                .withReverseLimitSource(ReverseLimitSourceValue.LimitSwitchPin)
                .withReverseLimitType(ReverseLimitTypeValue.NormallyOpen)
        )
        .withMotionMagic(
            leaderInitialConfigs.MotionMagic.clone()
                .withMotionMagicCruiseVelocity(RotationsPerSecond.of(66))
                .withMotionMagicAcceleration(RotationsPerSecondPerSecond.of(333.33333333333337))
        );

    public Elevator() {
        for (int i = 0; i < kNumConfigAttempts; ++i) {
            var status = motor_id_0.getConfigurator().apply(motor_id_0Configs);
            if (status.isOK()) break;
        }


        /* set the default command to neutral output */
        setDefaultCommand(manualDrive(() -> 0.0));
        /* alternatively, the default command can hold position */
        // setDefaultCommand(holdPosition());

        SmartDashboard.putData("Elevator", mech2d);

        if (Utils.isSimulation()) {
            startSimThread();
        }
    }

    /**
     * @return The Position of the elevator
     */
    public Angle getPosition() {
        return motor_id_0Position.getValue();
    }

    /**
     * @return The Velocity of the elevator
     */
    public AngularVelocity getVelocity() {
        return motor_id_0Velocity.getValue();
    }

    /**
     * @return The TorqueCurrent of the elevator
     */
    public Current getTorqueCurrent() {
        return motor_id_0TorqueCurrent.getValue();
    }

    /**
     * Holds the elevator at the current position using PID.
     *
     * @return Command to run
     */
    public Command holdPosition() {
        return runOnce(() ->
            setpointRequest.withPosition(motor_id_0Position.getValue())
        ).andThen(run(() -> {
            motor_id_0.setControl(setpointRequest);
        }));
    }

    /**
     * Drives the elevator to the provided position setpoint.
     *
     * @param setpoint Function returning the setpoint to apply
     * @return Command to run
     */
    public Command goToSetpoint(Supplier<Setpoint> setpoint) {
        return run(() -> {
            setpointRequest.withPosition(setpoint.get().target);
            motor_id_0.setControl(setpointRequest);
        });
    }

    /**
     * Manually drives the elevator with the provided duty cycle output.
     *
     * @param manualOutput Function returning the duty cycle to apply
     * @return Command to run
     */
    public Command manualDrive(DoubleSupplier manualOutput) {
        return run(() -> {
            manualRequest.withOutput(manualOutput.getAsDouble());
            motor_id_0.setControl(manualRequest);
        });
    }

    /**
     * Recalibrates the elevator zero point. This slowly drives the elevator
     * down until we see a drop in velocity and a spike in stator current,
     * indicating that we've hit a hard stop.
     *
     * @return Command to run
     */
    public Command calibrateZero() {
        return run(() -> {
            motor_id_0.setControl(calibrationRequest);
        })
        .until(isHardStop)
        .andThen(
            manualDrive(() -> 0.0).withTimeout(0.25)
                .finallyDo(() -> {
                    motor_id_0.setPosition(Rotations.of(0));
                })
        );
    }

    @Override
    public void periodic() {
        /* refresh all status signals */
        BaseStatusSignal.refreshAll(
            motor_id_0Position,
            motor_id_0Velocity,
            motor_id_0TorqueCurrent
        );

        motor_id_0Mech2d.setLength(
            motor_id_0Position.getValueAsDouble() * kDrumRadius.in(Meters) * 2 * Math.PI
        );
    }

    private void startSimThread() {
        motor_id_0.getSimState().Orientation = ChassisReference.CounterClockwise_Positive;
        motor_id_0.getSimState().setMotorType(TalonFXSimState.MotorType.KrakenX60);

        lastSimTime = Utils.getCurrentTimeSeconds();

        /* Run simulation at a faster rate so PID gains behave more reasonably */
        simNotifier = new Notifier(() -> {
            /* Calculate the time delta */
            final double currentTime = Utils.getCurrentTimeSeconds();
            final double deltaTime = currentTime - lastSimTime;
            lastSimTime = currentTime;

            final var motor_id_0Sim = motor_id_0.getSimState();

            /* First set the supply voltage of all the devices */
            motor_id_0Sim.setSupplyVoltage(RobotController.getBatteryVoltage());

            /* Then calculate the new position and velocity of the simulated elevator */
            elevatorSim_motor_id_0.setInputVoltage(motor_id_0Sim.getMotorVoltage());
            elevatorSim_motor_id_0.update(deltaTime);

            /* Apply the new rotor position and velocity to the motors (before gear ratio) */
            motor_id_0Sim.setRawRotorPosition(
                Radians.of(elevatorSim_motor_id_0.getPositionMeters() / kDrumRadius.in(Meters) * kGearRatio)
            );
            motor_id_0Sim.setRotorVelocity(
                RadiansPerSecond.of(elevatorSim_motor_id_0.getVelocityMetersPerSecond() / kDrumRadius.in(Meters) * kGearRatio)
            );
        });
        simNotifier.startPeriodic(kSimLoopPeriod);
    }
}